# üß™ Real-Time Inventory Management: When the Database Becomes a Bottleneck

## 1. Overview
This experiment demonstrates how a synchronous architecture that directly interacts with a relational database becomes a performance bottleneck under high load ‚Äî and how introducing a message broker (RabbitMQ Streams) helps to maintain system reliability, consistency, and SLA compliance.

The goal is to **experience the problem**, not just describe it ‚Äî to see how database contention, index updates, and isolation levels can degrade performance, and how message-driven processing mitigates these effects.

---

## 2. Context and Scenario
We simulate a simplified **e-commerce inventory system** where users can purchase a single product (SKU).  
Each purchase:
1. Checks item availability
2. Decreases stock atomically
3. Creates an order record

The system must ensure:
- No duplicate orders  
- Stock never drops below zero  
- p99 latency under 500 ms

Initially, the architecture works fine ‚Äî until the service becomes popular.  
As concurrent purchases increase, database contention rises, locks accumulate, and p99 latency spikes.  
The database becomes the single bottleneck in the critical path.

---

## 3. Experiment Purpose
We aim to demonstrate:
- **Why** synchronous write-heavy architectures degrade under load  
- **How** message brokers (RabbitMQ Streams) decouple ingestion and processing  
- **What** ‚Äúexactly-once semantics‚Äù mean in practice  
- **How** idempotency and controlled concurrency eliminate duplicate orders and contention

---

## 4. Architecture Variants

### 4.1 Synchronous Baseline
Each `POST /purchase` request performs:
1. A transactional update to `stock.available`
2. An indexed insert into `orders` table
3. Commit and immediate response to the client

Under growing RPS:
- Many concurrent transactions update the same row (`stock.available`)
- Index updates in `orders` slow down inserts
- Lock waits accumulate  
- p99 latency exceeds 500 ms and error rate grows

**Observed issue:** The database becomes the system‚Äôs bottleneck due to atomic updates, isolation, and indexing overhead.

---

### 4.2 Asynchronous Architecture (RabbitMQ Streams)
The `POST /purchase` endpoint:
1. Validates the request  
2. Appends a purchase event into a durable RabbitMQ Stream  
3. Returns `202 Accepted` immediately

A background **consumer** processes events:
1. Reads event from the stream
2. Atomically decreases stock and inserts order into the database
3. Acknowledges (commits offset) **only after** successful DB commit

**Result:**
- The API remains responsive under high load  
- Stream backlog grows but drains predictably  
- Database writes become short, isolated, and evenly distributed  
- SLA remains within limits (p99 < 500 ms, no duplicates)

---

## 5. Understanding Duplicates and Exactly-Once Semantics

Even with correct business logic, **duplicate orders** can appear due to retries and network behavior.

**Example:**  
The client sends `POST /purchase`, the server writes to DB but the response times out.  
The client retries, creating a second order with identical data.

In asynchronous systems, a similar issue occurs if a consumer crashes after writing to DB but before acknowledging ‚Äî the broker resends the message, and another consumer writes the same order again.

To prevent this, we apply **idempotency** and **exactly-once semantics**:

1. **Idempotency Key**  
   - Generated by the client (e.g., UUID) per purchase intent  
   - Stored in DB with a unique constraint  
   - Guarantees that repeated events do not duplicate state

2. **Exactly-Once Effect**  
   Achieved by:
   - Durable message storage (RabbitMQ Streams)  
   - Acknowledging messages only *after* successful commit  
   - Using idempotent DB operations (`INSERT ‚Ä¶ ON CONFLICT DO NOTHING`)  

> Even if the same message is delivered multiple times,
> the resulting state in the database changes **exactly once**.

---

## 6. Delivery Semantics Recap

| Semantics | Guarantee | Behavior |
|------------|------------|-----------|
| **At Most Once** | Message delivered 0 or 1 times | Fast but may lose data |
| **At Least Once** | Delivered ‚â• 1 times | Reliable but may duplicate |
| **Exactly Once** | Effect applied once | Combines durable storage + idempotent handling |

RabbitMQ Streams provides:
- **Durable, sequential storage** of messages  
- **Consumer offsets** that can be committed precisely  
- **Publish confirmations** for reliable append  
These allow building an **effectively exactly-once** pipeline.

---

## 7. Real-World Note
> ‚ö†Ô∏è This is a simplified educational example.  
> Real-world order systems usually include:
> - Soft reservations and stock holds  
> - Payment authorization and capture flow  
> - Split orders or partial fulfillment  
> - Complex workflows for cancellations and returns  

In production, idempotency keys, distributed transactions, and event-driven coordination are used across multiple services (checkout, payments, fulfillment, notifications).

---

## 8. Observations and Expected Results

| Metric | Sync Architecture | Async (Streams) | Expected Impact |
|---------|------------------|----------------|----------------|
| p99 Latency | > 800 ms | < 150 ms | ‚Üì Stable under load |
| Error Rate | 1‚Äì2 % | < 0.1 % | ‚Üì Fewer timeouts |
| DB Lock Wait | High (hundreds ms) | Minimal (< 10 ms) | ‚Üì Less contention |
| Orders/sec | ‚âà 300 TPS | ‚âà 900 TPS | ‚Üë 3√ó throughput |
| Duplicates | Possible | None | Eliminated |

---

## 9. Key Takeaways
- **Queues do not speed up the database directly.**  
  They *buffer* load and allow controlled, cost-effective writes (append, batch, or serialized).
- **Brokers decouple acceptance from persistence**, preserving SLA and protecting the DB.
- **Idempotency** makes repeat deliveries safe.  
- **Exactly-once semantics** ensure correctness even with retries.
- **RabbitMQ Streams** provide the building blocks for this guarantee: durability, offsets, and confirmation flow.

---

## 10. Steps To Reproduce
*(to be filled after implementation)*
